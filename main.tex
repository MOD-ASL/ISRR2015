%%%%%%%%%%%%%%%%%%%% author.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample root file for your "contribution" to a contributed volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% RECOMMENDED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[graybox]{svmult}

% choose options for [] as required from the list
% in the Reference Guide
\usepackage{pdfsync}
\usepackage{mathptmx}       % selects Times Roman as basic font
\usepackage{helvet}         % selects Helvetica as sans-serif font
\usepackage{courier}        % selects Courier as typewriter font
\usepackage{type1cm}        % activate if the above 3 fonts are
                            % not available on your system
%
\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
                             % when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom
\usepackage{titlesec}

\titlespacing\section{0pt}{20pt plus 2pt minus 2pt}{20pt plus 2pt minus 2pt}
% see the list of further useful packages
% in the Reference Guide

\makeindex             % used for the subject index
                       % please use the style svind.ist with
                       % your makeindex program

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%  Our packages and macros   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% numbers option provides compact numerical references in the text. 
\usepackage[numbers]{natbib}
%\usepackage{multicol}
\usepackage[bookmarks=true]{hyperref}
\usepackage{color}
%\usepackage{graphicx}
%\usepackage{subfloat}
\usepackage{textcomp}
%\usepackage{amsthm}
%\usepackage{amsfonts}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pbox}
\usepackage[normalem]{ulem}

%\theoremstyle{definition}
%\newtheorem{definition}{Definition}[section]
\usepackage{amsmath}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%% Tarik's Shortcuts
% For marking TODOs in an obvious way
\newcommand{\TODO}[1]{ {\bf \textcolor{red}{TODO:} #1 }}
\newcommand{\abj}[1]{\textcolor{blue}{#1}}
\newcommand{\dbj}[1]{\textcolor{blue}{\sout{#1}}}
\newcommand{\cbj}[2]{\textcolor{blue}{\sout{#1}}\textcolor{blue}{~#2}}
\newcommand{\abt}[1]{\textcolor{magenta}{#1}}
\usepackage{amsbsy}
\usepackage{overpic}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}

\title*{Computer-Aided Compositional Design and Verification for Modular Robots}

% You will get a Paper-ID when submitting a pdf file to the conference system
\author{Tarik Tosun$^*$, Gangyuan Jing$^*$, Hadas Kress-Gazit, and Mark Yim}

\institute{
Tarik Tosun \at University of Pennsylvania, Philadelphia PA, \email{tarikt@grasp.upenn.edu}
\and Gangyuan Jing \at Cornell University, Ithaca NY, \email{gj56@cornell.edu}
\and Hadas Kress-Gazit \at Cornell University, Ithaca NY, \email{hadaskg@cornell.edu}
\and Mark Yim \at University of Pennsylvania, Philadelphia PA, \email{yim@grasp.upenn.edu}
\and $^*$ Tarik Tosun and Gangyuan Jing contributed equally to this work.
}

\maketitle

\abstract{To take full advantage of the flexibility of a modular robot system,
users must be able to create and verify new configurations and behaviors quickly. We
present a design framework  that facilitates  rapid creation of new
configurations and behaviors through composition of existing ones, and tools to
verify configurations and behaviors as they are being created. New
configurations are created by combining existing sub-configurations, for example
combining four legs and a body to create a walking robot. Behaviors are
associated with each configuration, so that when sub-configurations are
composed, their associated behaviors are immediately available for composition
as well. We introduce a new motion description language (Series-Parallel Action
Graphs) that facilitates the rapid creation of complex behaviors by composition
of simpler behaviors. We provide tools that automatically verify configurations
and behaviors during the design process, allowing the user to identify problems
early and iterate quickly. In addition to verification, users can  evaluate their
configurations and behaviors in a physics-based simulator.
%The software we have developed is open-source, and will be made freely available online.
}

\section{Introduction} 

Modular reconfigurable robot systems have been studied extensively for several
decades.  These systems distinguish themselves from conventional robotic systems in their ability to transform into different shapes to address a wide variety of tasks. They promise to be versatile, robust, and low cost
\cite{yim2000polybot}. Dozens of groups have  built different kinds of reconfigurable robots
\cite{fukuda1990cellular, lipson2000towards}, and introduced approaches for
programming them \cite{salemi2001hormone, stoy2002using,
zhang2003phase}.  Over 800 papers, a book \cite{stoy2010book}, and a survey \cite{yim2007modular} have been written on the subject.

This versatility places an additional burden on the user, because
solving problems with modular robots involves not only writing  programs,
but also determining the best physical form for the task at hand. If this
complexity is not appropriately managed, it will present a significant barrier to
using modular robots to address practical tasks \cite{yim2000modular}. If the user is free to create any new design to
solve a new task, but must program the design from scratch every time, creating
new designs will be a huge amount of effort, and the advantage of versatile modular
hardware will be defeated.

Software modularity is a well-established practice for developing large
maintainable systems and avoiding duplication of effort. In robotics, software
behaviors are inextricably linked to the hardware they control, resulting in challenges to making modularity effective. Significant progress has been made on these fronts
in traditional robotics, most notably
ROS \cite{Quigley2009} which provides inter-process communication and standard libraries for common robot tasks,
as well as verification tools \cite{huang2014rosrv}.
In modular robotics, the challenge is different.  Modular robot systems are not usually
optimized
for specific tasks, so in order to use them most effectively, we must take advantage of their flexibility. To do
so, a user must be able to generate and verify configurations and behaviors
as quickly as possible.  

Toward that end, we present a design framework that facilitates the rapid creation
of new configurations
and behaviors through composition, and tools to verify them
while they are being created. New configurations are created by combining existing
sub-configurations,
for example combining a four-legged walking robot with a two-fingered gripper
to form a mobile manipulator, like the ``Centaur'' configuration shown in Figure~\ref{fig:walk}
.
Behaviors are associated with each configuration, so that when sub-configurations
are composed, their associated behaviors are immediately available for use.
The Centaur in Figure~\ref{fig:walk}, for example, can immediately execute the
walking behavior of its component four-legged base. We introduce a new motion description language (Series-Parallel Action Graphs,
Section~\ref{sec:behavior-representation})
that facilitates the rapid creation of complex behaviors by composition of simpler
behaviors (for example, composing  ``Grasp'' and ``Walk'' behaviors to make
the Centaur pick up and carry an object).
We provide tools that automatically verify configurations and behaviors during the
design process, 
identifying conflicting
commands, self-collision, loss of gravitational stability, and forces 
exceeding the limits of safety for actuators and connectors. This allows users
to identify problems early and iterate quickly on complex new designs. In addition to verification, users can  evaluate their configurations and behaviors in a physics-based simulator.
The software we have developed is open-source, and will be made freely available
online at: \texttt{http://modlabupenn.org/compositional-design/}.

The remainder of this paper provides a  description of the
structure and algorithmic components of our framework.  In Section \ref{sec:related-work},
we discuss relevant background material.
In Section \ref{sec:preliminaries} we introduce terminology and  concepts used elsewhere in the
paper. 
In Section \ref{sec:approach}, we describe the algorithmic basis
for the three major components of our framework - design composition, behavior
composition, and verification.  In Section
\ref{sec:implementation}, we discuss the open-source software
tools used to implement our framework. In Section \ref{sec:examples}, we provide examples highlighting
important aspects of the framework, including a demonstration of the user's
workflow.
% 
% We demonstrate that our framework saves the
% user time and effort, and allows him or her to easily develop complex and
% capable designs.

\begin{figure}
\begin{center}
                \includegraphics[width=0.23\textwidth]{images/library/unity/step1.png}
                \includegraphics[width=0.23\textwidth]{images/library/unity/step2.png}
                \includegraphics[width=0.23\textwidth]{images/library/unity/step3.png}
                \includegraphics[width=0.23\textwidth]{images/library/unity/step4.png}
                %\includegraphics[width=0.9\textwidth]{images/tikz/walkgraph.pdf}
\end{center}
\caption{The Centaur is a  mobile manipulator made of 29 modules. The framework
we present provides tools that help users quickly create, program, and verify complex designs
like the Centaur by composing existing designs and behaviors from a library.  }
\label{fig:walk}
\end{figure}
% \begin{figure}
%   \begin{center}
%     \includegraphics[width=0.9\textwidth]{images/tikz/walkgraph.pdf}
%     \caption{Parallel Series Action Graph of a walking behavior.}
%     \label{fig:walkgraph}
%   \end{center}
% \end{figure}


\section{Related Work} \label{sec:related-work} 
In some respects, our work parallels the efforts of Mehta \cite{mehta2014design}
and Bezzo \cite{bezzo2014demo}, who aim to create and program printable robots
from novice users' design specifications.  Users create new designs by composing
existing elements from a design library, and appropriate circuitry and control
software are automatically generated as physical designs are assembled. The
framework we present is intended specifically for modular robots, and
consequently the workflow and design considerations are fundamentally different
from that presented by Mehta and Bezzo.  In traditional robot design (or
printable robot design), hardware and software are somewhat decoupled - hardware
is designed and built once, and then programmed many times.  In the case of a
modular robot system, the system can be reconfigured to meet new tasks, so
hardware configuration and behavior programming go hand in hand.  We intend our
system to be fast enough that the user could conceivably develop and program a
new configuration for every new task - configurations are built once, and programmed once.
Where Mehta et al. provide many facilities to generate and verify low-level
behaviors (\textit{e.g.} motor drivers appropriate for motors), we do so for
high-level behaviors.

A significant amount of work has been done in developing behaviors and software
for modular robots. Genetic algorithms
have been applied for the automated generation of designs and behaviors
\cite{hornby2003generative}. Other work has focused on distributed control
\cite{walter2002choosing}, hormone-based control \cite{salemi2001hormone}, and
central pattern generators \cite{sproewitz2008learning}.

Efforts have also been made to generate behaviors by automatically identifying the ``role'' a module should play based on its place in a connected structure \cite{stoy2002using}.  Functionality is propagated downward: based on a high-level goal (like ``walk'') and a connected structure of modules, functional sub-structures (like legs and a spine) are automatically identified, and modules are directed to execute appropriate roles in a distributed fashion.  In our work, modular structures are similarly associated with appropriate behaviors. Rather than identifying roles in a top-down fashion, we build designs with the desired functionality from the bottom up. The user creates new designs by composing sub-components and associated behaviors from a library, building a new structure that can definitely execute the desired behavior.

While significant progress has been made in the automated generation of modular
robot behaviors, automated systems are not yet capable of making modular robots
truly useful in practice \cite{yim2007modular}.  The need for new programming
techniques to manage the complexity of modular robot systems has been
acknowledged in the literature \cite{yim2000modular}. Historically, gait tables
have been a commonly used format in which open-loop kinematic behaviors can be
easily encoded \cite{yim1994locomotion}. Phased automata have also been
presented as a way to easily create scalable gaits for large numbers of modular
robots \cite{zhang2003phase}. In this paper, we introduce a novel motion
description language that enables users to quickly create behaviors for modular
robots.

A number of robot simulators have been developed, including simulators specifically for modular robots \cite{christensen2008unified}. For our work, we opted to use Gazebo \cite{koenig2004design} because of its growing popularity in the robotics community. While our software currently only supports the SMORES robot \cite{Davey2012}, other modular robot designs can easily be incorporated. Future work includes incorporating  support for the CKBot robot \cite{davey2012modlock}.

Our framework assists users in verifying design validity by identifying conflicting
commands, self-collision, loss of gravitational stability, and forces 
exceeding the limits of safety for actuators and connectors. In existing literature, some
of these
conditions have been checked in the context of modular robot reconfiguration
planning \cite{casal2001reconfiguration} and motion planning
\cite{yoshida2002self}. To our knowledge, there is no modular robot design tool
that verifies these conditions to provide assistance to a human designer.

\section{Definitions}
\label{sec:preliminaries}
In this section, we present concepts and terms which will be used later in the paper.

\begin{definition}[Module] A module is a small robot that can move, respond to commands,
and attach to other modules.  Formally, we define a  module  as
$\mathcal{M}=({^\mathcal{W}}D^{\mathcal{M}}, X, A,K)$.
The rigid body \textit{displacement}, ${^\mathcal{W}}D^{\mathcal{M}}\in SE(3)$ 
gives the position and orientation of the module body frame in the world  frame $\mathcal{W}$.
The \textit{state} of the module, \(X=\lbrack x_1, x_2, \ldots, x_d \rbrack\),
 is a \(d\)-dimensional vector representing the \(d\) joint angles of the module.
$A=\{a_1, a_2, ..., a_k\}$ is the set of \textit{attachment points} where the 
module can connect to other modules.
The  module's \textit{forward kinematics function}, \(K: (X, a_i) \rightarrow SE(3) \) 
returns \({^\mathcal{M}}D^{a_{i}}\) (the displacement of attachment point \(a_i\) 
in the module frame) as a function of \(X\).
% , where:
% \begin{itemize}
% \item ${^\mathcal{W}}D^{\mathcal{M}}\in SE(3)$ is the rigid-body \textit{displacement} (position and orientation)
% of the module body frame in the world reference frame $\mathcal{W}$. 
% \item \(X=\lbrace x_1, x_2, \ldots, x_d \rbrace\) is the \textit{state} of the module,
% with each \(x_i\) corresponding to one of the \(d\) degrees of freedom (DoF) of the module.
% \item $A=\{a_1, a_2, ..., a_k\}$ is the set of \textit{attachment points} where the module can connect to other modules.
% \item \(K: (X, a_i) \rightarrow SE(3) \) is the module's \textit{forward kinematics function}, returning \({^\mathcal{B}}D^{a_{i}}\) (the displacement of attachment point \(a_i\) in the body frame) as a function of \(X\)
% \end{itemize}
%
Figure~\ref{fig:graphical-representations} shows a schematic representation of a module with  four attachment points.

In this paper, we demonstrate our framework using a homogeneous modular robot system (all modules are identical). The framework could be extended to heterogeneous systems by including more information in the definition of a module - for example, if the system used multiple kinds of connectors, labels on the attachment points could be included. 
\end{definition}
%
% \begin{figure}
% \begin{center}
%         \begin{subfigure}[b]{0.4\columnwidth}
%                 \begin{center}
%                 \includegraphics[width=0.7\textwidth]{images/smores.JPG}
%                 \caption{A module}
%                 \end{center}
%                 \label{fig:smores_photo}
%            \end{subfigure}
%            ~
%         \begin{subfigure}[b]{0.4\columnwidth}
%                 \begin{center}
%                 \includegraphics[width=0.7\textwidth]{images/tikz/smores.pdf}
%                 \caption{The graphical representation}
%                 \end{center}
%                 \label{fig:smores_graph}
%         \end{subfigure}
% \end{center}
% \caption{A photo of a module and its graphical representation}
% \label{fig:smores}
% \end{figure}
%
% \begin{figure}
% \sidecaption
% %\begin{center}
%         \includegraphics[height=1.1in]{images/smores.JPG}
%         \includegraphics[height=1.1in]{images/tikz/smores.pdf}
% %\end{center}
% \caption{A photo of a module (left) and its graphical representation (right)}
% \label{fig:smores}
% \end{figure}
\begin{figure}
%1 
\begin{overpic}[height=1.0in]{images/smores_robot.png}
  \put(3,30) {(1)}
\end{overpic}
%2 
\begin{overpic}[height=1.0in]{images/tikz/smores.pdf}
  \put(3,8) {(2)}
\end{overpic}
%3
\begin{overpic}[height=1.0in]{images/smores_conf.JPG}
  \put(4,6) {(3)}
\end{overpic}
%4
\begin{overpic}[height=1.0in]{images/tikz/smores_conf.pdf}
  \put(4,6) {(4)}
\end{overpic}
\caption{From left: (1) A photo of a SMORES module with four attachment points
(left, right, front, and back), (2) its graphical representation, (3)
a photo of a configuration with three modules, and (4) its graphical representation.}
\label{fig:graphical-representations}
\end{figure}


\begin{definition}[Configuration]
\label{def:configuration}
A \textit{configuration} is a contiguous set of connected modules which we treat as a
single robot.  The identity of a configuration is determined by its connective structure; configurations
can be represented by graphs with nodes representing modules and edges
representing connections between modules.   Individual modules
are considered interchangeable (as long as they are of the same type).

In this paper, we present an object-oriented design framework for modular robot
systems, and treat configurations as the fundamental objects. Rather than defining
configurations only by the topology of their component modules, we define them recursively,
as being composed of connected sub-configurations. A single module is considered the
smallest configuration.

Formally, we define a configuration as $\mathcal{C}=(C_, \gamma, M, E, \delta,
X, B)$.
%
Here, $C=\{\mathcal{C}_{1}, \mathcal{C}_{2}, ..., \mathcal{C}_{q}\}$ is a set of sub-configurations.
%
$\gamma: C \rightarrow 2^M$ is a function {mapping} a configuration \( \mathcal{C}_i \in C\) to its set of modules,  \( M=\bigcup_{\mathcal{C}\in C}{\gamma(\mathcal{C})} \).
%
$E$ is a set of connections between modules. Elements of \(E\) are pairs of
attachment points, $(\mathcal{M}_i.a_i, \mathcal{M}_j.a_j)\in E,$ where $\mathcal{M}_{i},\mathcal{M}_j \in M, \mathcal{M}_i \neq \mathcal{M}_j$, and $a_i\in \mathcal{M}_i.A$, $a_j\in \mathcal{M}_j.A$.
%
The orientation of one attachment point relative to another is represented by the
labeling function $\delta: E \rightarrow SO(3)$, returning \({^{\mathcal{M}_i.a_i}}R^{\mathcal{M}_j.a_j}\).
%
The \textit{state} of the configuration is \(X = \bigcup_{\mathcal{M}_i \in M} \mathcal{M}_i.X \).
%
Finally, associated with each configuration is a set of \textit{behaviors} \(B\)
(see Definition~\ref{def:behavior}).

% , where:
% \begin{itemize}
% \item $C$ is a set of sub-configurations, $C=\{\mathcal{C}_{1}, \mathcal{C}_{2}, ..., \mathcal{C}_{q}\}$.
% \item $\gamma: C \rightarrow 2^M$ is a function {mapping} a configuration \( \mathcal{C} \in C\) to its set of modules.
% % Note: if we define a single module as the smallest configuration, we don't have
% % to worry about the case when the configuration contains no configurations.
% \item \( M=\bigcup_{\mathcal{C}\in C}{\gamma(\mathcal{C})} \) is the set of modules.
% %\item $M$ is the set of modules. If this configuration contains no other configurations, i.e. $C = \emptyset$, $M$ is just the set of all modules of this configuration. If this configuration is composed by other configurations, i.e. $C=\{\mathcal{C}_{1}, \mathcal{C}_{2}, ..., \mathcal{C}_{q}\}$, we define $M=\bigcup_{\mathcal{C}\in C}{\gamma(\mathcal{C})}$.
% \item $E$ is a set of connections between modules. $(\mathcal{M}_i.a_i, \mathcal{M}_j.a_j)\in E,$ where $\mathcal{M}_{i},\mathcal{M}_j \in M, \mathcal{M}_i \neq \mathcal{M}_j$, and $a_i\in \mathcal{M}_i.A$, $a_j\in \mathcal{M}_j.A$.
% \item $\delta: E \rightarrow SO(3)$ is a labeling function over connections returning
% \({^{\mathcal{M}_i.a_i}}R^{\mathcal{M}_j.a_j}\), the orientation of one attachment point relative the
% other.
% \item \(X = \displaystyle\bigcup_{\mathcal{M}_i \in M} \mathcal{M}_i.X \) is the \textit{state} of the configuration.
% \item \(B\) is a set of \textit{behaviors} (Definition~\ref{def:behavior}) associated with the configuration.
% \end{itemize}

Figure~\ref{fig:graphical-representations} shows a photo of a configuration composed
of three modules, each with four attachment points, and its
graphical representation. Blue zigzag lines represent connections between
modules, and the label of each connection shows the angle offset of that
connection.
%Assuming acyclic configurations, w
We can compute forward kinematics for the entire
configuration by composing displacements module-to-module. Let any module \(\mathcal{M}_f \in M\) have
fixed displacement \({^\mathcal{W}}D^{\mathcal{M}_f}\) in the world frame.
Let \(\mathcal{M}_i: (\mathcal{M}_i.a_i,~\mathcal{M}_f.a_f) \in E \) be connected to \(\mathcal{M}_f\).
 We can find \({^\mathcal{W}}D^{\mathcal{M}_i}\) by composing displacements as follows:
\begin{align*}
{^\mathcal{W}}D^{\mathcal{M}_i} =& [{^\mathcal{W}}D^{\mathcal{M}_f}] [{^{\mathcal{M}_f}}D^{a_f}][
{^{a_f}}D^{a_i}] [{^{\mathcal{M}_i}}D^{a_i}]^T \\
=& [{^\mathcal{W}}D^{\mathcal{M}_f}] [K_f(X_f,a_f)] \begin{bmatrix} \delta(e) & 0
\\ 0 & 1\end{bmatrix} [K_i(X_i,a_i)]^T
\end{align*}

where \(e=(\mathcal{M}_i.a_i,~\mathcal{M}_f.a_f)\). To find the world-frame displacements
of all other modules, we may traverse the connections of the configuration,  repeatedly
composing displacements in the manner above. 
\end{definition}

% \begin{figure}
% \begin{center}
%         \begin{subfigure}[b]{0.4\columnwidth}
%                 \includegraphics[width=0.7\textwidth]{images/smores_conf.JPG}
%                 \caption{A configuration}
%                 \label{fig:smores_conf_photo}
%         \end{subfigure}
%            ~
%         \begin{subfigure}[b]{0.4\columnwidth}
%                 \includegraphics[width=0.7\textwidth]{images/tikz/smores_conf.pdf}
%                 \caption{The graphical representation}
%                 \label{fig:smores_conf_graph}
%         \end{subfigure}
% \end{center}
% \caption{A photo of a configuration with three modules and its graphical representation}
% \label{fig:smores_conf}
% \end{figure}
% \begin{figure}
% \sidecaption
% \includegraphics[height=1.2in]{images/smores_conf.JPG}
% \includegraphics[height=1.2in]{images/tikz/smores_conf.pdf}
% \caption{A photo of a configuration with three modules (left) and its graphical representation (right).}
% \label{fig:smores_conf}
% \end{figure}


\begin{definition}[Behavior]\label{def:behavior}
A \textit{behavior} \(B:(t,X)\to X_{set}\) is a programmed sequence of movements defined
over the joints of a specific configuration, and
intended to produce a desired effect - a gait for walking is one example.  Behaviors
determine the controller setpoints \(X_{set}\) for a configuration as a function
of state \(X\) and time \(t\). In this paper, we represent behaviors as
series-parallel action graphs, described in detail in section
\ref{sec:behavior-representation}.
\end{definition}
\begin{definition}[Controller]
A \textit{controller} is a position or velocity servo for one DoF of a modular
robot.  A controller takes as input a desired position or angular velocity, and
drives the error between the desired and actual state of the DoF it controls to
zero over time.
\end{definition}

% \begin{definition}[Behavior Conflict]
% When writing a behavior, it is possible to command one controller to
% simultaneously hold more than one desired position; this is known as a
% \textit{behavior conflict}.  Behaviors with conflicts are
% impossible to execute.
% \end{definition}
% \begin{definition}[Self-Collision]
% During execution of a behavior, a \textit{self-collision} can occur when two
% different parts of configuration are commanded to occupy the same location in
% space.  Self-collisions can damage the robot, and are usually unwanted.
% \end{definition}
% \begin{definition}[Gravitational Stability]
% While executing many behaviors, it is desirable to maintain \textit{gravitational
% stability} (also called quasi-static stability).  Informally speaking, a
% robot is gravitationally stable when it is balanced, and gravity does not
% create any net moment on it.  Mathematically, the robot is gravitationally stable
% if the projection of its center of
% mass onto the group plane lies within the convex hull of its load-supporting contact points in the
% ground plane.
% \end{definition}
% \begin{definition}[Maintain Connections and Joint Angles]
% Due to the force limit of mechanisms in each module, there maybe situations, 
% especially during execution of a behavior, when force provided is not sufficient to
% maintain all connections between modules in a configuration, or to maintain all joints at desired positions.
% \end{definition}
% 

\section{Approach and Algorithm} \label{sec:approach} The three major
components of our framework are configuration composition, behavior
composition, and verification of configurations and behaviors.  Together,
these three components provide a streamlined workflow to quickly create
functional robots by leveraging an existing library of designs and behaviors.
Combining existing designs and behaviors into new ones allows users to create
large, complicated, functional designs.

\subsection{Configuration Composition} \label{sec:conf_composition}

Before discussing configuration composition, we will first define a set of connections $E_C$ between configurations in a given set $C$ as $(\mathcal{C}_i.\mathcal{M}_i.a_i, \mathcal{C}_j.\mathcal{M}_j.a_j) \in E_C$, where $\mathcal{C}_{i},\mathcal{C}_j\in C$, $\mathcal{M}_i \in \gamma(\mathcal{C}_i), \mathcal{M}_j \in \gamma(\mathcal{C}_j)$, and $a_i\in \mathcal{M}_i.A$, $a_j\in \mathcal{M}_j.A$. We form a
 graph with configurations in $C$ as nodes and connections in $E_C$ as edges.
%\begin{definition}[Configuration Composition]

Given a set of configurations $C$ and a set $E_C$ of connections between them,
configuration composition combines all configurations in $C$ to a single
configuration $\mathcal{C}^*$ that includes all modules and connections from $C$
and $E_C$. The composed configuration is $\mathcal{C}^*=(C^*, \gamma, M, E, \delta,
X, B)$, where \(C^*\), \(M\), \(E\), and \(B\) are  the unions of the
corresponding sets of the sub-configurations in \(C\).
%The definitions of $\gamma$, \(X\), and $\delta$ remain unchanged from Definition~\ref{def:configuration}. 
%\end{definition}

\subsection{Behavior Composition: Series-Parallel Action Graphs}
\label{sec:behavior-representation}
The modular robotics community has developed a number of methods
to create behaviors, including gait tables \cite{yim1994locomotion}, phased automata
\cite{zhang2003phase}, hormone-based control \cite{salemi2001hormone},
and role-based control \cite{stoy2002using}. Phased automata, hormone, and role-based
control are typically used to specify a single, cyclic behavior (such as a gait for
locomotion) in a distributed fashion.
These methods have good scaling and robustness properties, but are not well-suited
to specifying  the non-cyclic, globally coordinated behaviors required for many tasks
(like picking up and moving an object with an arm).
  
The simplicity and clarity of gait tables makes them appealing for our
application.  However, gait tables are often difficult to compose or re-use, and also hard to
scale to very complicated designs. The  motion description language we present
allows low-level behaviors to be combined in series and parallel to create new
higher-level behaviors, encapsulating complexity and facilitating code re-use.
The resulting programs are expressive, and have a nested structure
that is easy to understand and debug.

%    
% We present a novel motion description language for modular robots.  The
% language aims to balance simplicity and expressiveness, and is designed specifically
% for composition, allowing complex behaviors
% to be rapidly created by combining existing behaviors. 
% Typical motion description languages have atomic elements that represent controller
% commands (set-points and gains) with limited duration \cite{brockett1988computer}.
% Extended motion description languages introduce interrupts to control the duration
% of commands \cite{hristu2003motion}.  Our language distinguishes itself by allowing
% existing behaviors to be easily composed to form new behaviors.

 The atoms of the language are called \textit{actions}.  Similar to a single entry of a gait
table, an action specifies a controller setpoint for a single DoF of a module.  Unlike
a gait table entry, actions do not have explicit timestamps.  Rather, each action has an associated
interrupt condition, which is a boolean function of the (sensed) state of the robot. Similar
to a state transition in a finite state machine (FSM), when the interrupt condition is met the action is  considered
complete, and  execution moves on to the next action.  Interrupts allow the programmer
to precisely specify behaviors in a natural way: rather than specifying a timed sequence
of motions, the programmer specifies an ordered sequence of actions and has some
assurance that an action will not begin until the robot has actually achieved the goal
state of the previous action. Actions
may optionally include a timeout, which causes the action to be considered complete
automatically once time runs out.

An important distinction between actions in our language and states in a traditional
FSM is that multiple actions may execute in parallel.   Actions are combined through
parallel and series composition to create behaviors. When two actions are composed in series,
the second begins when the first ends. When composed in parallel they
begin simultaneously, and the following actions do not begin until both complete.
A behavior created using these operations is a directed acyclic graph of actions with
series-parallel structure \cite{valdes1979recognition};  Figure \ref{fig:graph-composition} provides
a visual example.
% This structure is advantageous because the
%  series and parallel composition operations   
% remain valid for behaviors of arbitrary size, allowing new behaviors to be easily
% created by combining existing behaviors.
 
% The fundamental atoms of the language are called actions.  An \textit{action} is a tuple \(
% (J, X, \xi, T)\), where \(J\) identifies a single DoF of a configuration, \(X\) is a
% controller setpoint for that DoF, \(\xi\) specifies an interrupt
% condition, and T specifies a timeout. When an action executes, the controller
% setpoint (position or velocity) for the specified DoF is changed to the specified
% value. The controller maintains this setpoint until receiving a new one from another
% action. The interrupt condition is a boolean function of the (sensed) state of the DoF \(J\).
% When either the interrupt condition is met or time runs out (whichever comes
% first), the action is considered complete, and the next action  begins. The
% interrupt condition can be set to \(false\) (so that only the timeout has effect),
% and \(T\) can be set to infinity (so that only the interrupt has effect). As an example,
% the action \((~Module0\_L,~ \theta_{set}=\pi,~ \xi:\theta==\pi,~T:\infty~)\) encodes
% ``Command the controller of the left wheel of module zero to maintain a setpoint
% of \(\pi\) radians.  When the encoder of that wheel indicates that \(\pi\) radians
% has actually been reached, consider this action complete and move on.''
%  
% Actions are composed to form behaviors. We define a \textit{behavior} as a directed acyclic graph where nodes are
% actions and edges are transitions between actions.  A behavior \(B\) always has
% two special nodes \(S\) and \(T\), which are the \textit{Start} and
% \textit{   Termination} nodes, respectively.  The smallest behavior consists of
% \(S\), \(T\), and a single action.  Behavior execution follows three simple
% rules:
% 
% \begin{enumerate}
% \item Execution begins at \(S\).  \(S\) completes immediately.
% \item Each action begins execution upon completion of \textit{all} its parent actions.
% \item All sequences of execution end at \(T\).
% \end{enumerate}
% 
% Because execution begins at \(S\) and ends at \(T\), there must be a (directed)
% path from every \(S\) to every node in \(B\), and also from every node in \(B\)
% to \(T\). Since \(B\) is acyclic, it is therefore a \textit{directed series-parallel graph} (SPG).
% SPG's can always be formed recursively by parallel and series composition
% operations \cite{valdes1979recognition}. The parallel composition \(P\) of two behaviors \(B_1\),
% \(B_2\), \(P = Pc(B_1, B_2)\) is the disjoint union of their nodes (actions),
% merging \(S_1\) with \(S_2\) and \(T_1\) with \(T_2\). The series composition
% of \(B_1\), \(B_2\), \(S = Sc(B_1, B_2)\) is created from their disjoint union
% by merging \(T_1\) and \(S_2\), so that \(B_1\) and \(B_2\) execute
% sequentially\footnote{Since the merged node is not an action, we can freely
% omit it and instead draw edges from each of its parent nodes to each of its
% child nodes.}.  Note that if \(B_1\) was itself created through parallel
% composition, \(B_2\) will not begin until all chains of execution of \(B_1\)
% are completed. Figure \ref{fig:graph-composition} provides a visual companion.

\begin{figure}
\begin{center}
\includegraphics[height=0.9in]{images/tikz/series.pdf}
\includegraphics[height=0.95in]{images/tikz/parallel.pdf} \vspace{0.in}
\includegraphics[height=0.95in]{images/tikz/parallel-and-series.pdf}
\end{center}
\caption{Series and parallel composition}
\label{fig:graph-composition}
\end{figure}

%\subsubsection*{Example}
As an example, consider the car design shown in Figure \ref{fig:car-and-backhoe}. To create a low-level
``drive-forward'' behavior, we simply command all of its wheels to spin  in parallel.
The car steers by swiveling its central steering column, so a ``turn right''
behavior can be similarly achieved by commanding parallel actions for the steering column joints.
With these low-level behaviors established, we can command trajectories through series composition. For example, if we name our car configuration \texttt{c}: \texttt{c.square = \textbf{series}(c.drive, c.turn, c.drive, c.turn, c.drive, c.turn, c.drive, c.turn)}.

This paradigm  allows  low-level behaviors to be coded quickly and
easily. However, the real value comes from its ability to  combine behaviors
in layers and quickly generate behaviors for complicated designs. This works
particularly well when designs are made by composing smaller designs. For
example, we can develop ``drive'' and ``turn''\ behaviors for the
18-module backhoe shown in Figure \ref{fig:car-and-backhoe} (name \texttt{bh}) by composing  behaviors of its component car designs (named \texttt{c1} and \texttt{c2}):
\texttt{bh.drive = \textbf{parallel}(c1.drive, c2.drive)}, and \texttt{bh.turn = \textbf{parallel}(c1.turn, c2.turn)}.
Each of these one-line statements commands the movement of  28 degrees of freedom.

We can extend this further to generate high-level behaviors for the
backhoe.  Suppose that the arm has a laser rangefinder attached to the end,
and that we've already created a ``scan'' behavior that sweeps or rotates the
sensor.  We might create a ``patrol'' behavior that scans continuously while
driving in a square: \texttt{bh.patrol = \textbf{parallel}(bh.scan, bh.square)}. Or, if we only want
the robot to scan the corners of a room, we can precisely specify this using
lower-level behaviors: \texttt{bh.cornerScan = \textbf{series}(bh.drive, bh.scan, bh.turn,
bh.drive, bh.scan, bh.turn, \ldots)}.

% Building behaviors in a layered fashion make it much easier
% to re-use code.
% If primitive behaviors have not yet been built, building a single complicated behavior like ``patrol'' from scratch might  be faster
% than first building primitive behaviors and then composing them into the desired
% complex behavior. However, the latter process is more efficient in the long run,
% because the low-level behaviors can be re-used to quickly create many different
% high-level behaviors.

Building behaviors in this layered fashion makes it easy to re-use code and
quickly generate complicated behaviors. Of course, there is no guarantee that
two composed behaviors will be compatible; it is possible to mistakenly create
behaviors that are impossible or dangerous to execute. For this reason, we provide
verification tools that automatically identify problems - for example, if two
behaviors composed in parallel commanded the same DoF simultaneously (a problem
we call \textit{behavior conflict}),  this
would be automatically identified. Our verification tools are explained in detail
in Section~\ref{sec:verify}.

Our emphasis on abstraction begs the question: why not use  a a more fully-featured
plan execution model such as behavior trees \cite{marzinotto2014towards}, parallel-hierarchical
finite state machines \cite{sklyarov2008design} or even a
traditional object-oriented programming language (like Java or C++)?  Our
decision was driven by the tradeoff between complexity and ease-of-use: given
our desire for simplicity and speed of programming, we chose a
 minimal paradigm with only two composition operations.
The language is quite expressive: we have used it to develop complex behaviors
for large designs (see Section \ref{sec:examples}). The language is also limited:
it does not yet include conditional statements, iteration, or access to environmental
sensor
information (other than joint angles). In the future, we hope to include these capabilities without sacrificing ease-of-use. 
% \begin{figure}
% \begin{center}
%   \begin{subfigure}[b]{0.4\textwidth}
%     \includegraphics[height=1.1in]{images/library/car.png}
%     \caption{Car design}
%     \label{fig:car-design}
%   \end{subfigure}
%   \begin{subfigure}[b]{0.4\textwidth}
%     \includegraphics[height=1.1in]{images/library/backhoe.jpeg}
%     \caption{Backhoe design}
%     \label{fig:backhoe-design}
%   \end{subfigure}
% \end{center}
% \end{figure} 
%
\begin{figure}
\begin{center}
    \includegraphics[height=1.1in]{images/library/unity/car.png}
    \includegraphics[height=1.1in]{images/library/unity/backhoe.png}
    \caption{Car design (left) and backhoe design (right)}
    \label{fig:car-and-backhoe}
\end{center}
\end{figure} 

% Consider a single module that has two wheels that allow it to drive like a car. To
% drive forward, we might define a DRIVE behavior composing actions for  the left and right wheels
% in parallel:\begin{align*}
% \mathrm{DRIVE} =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\
% Pc \left( \begin{array}{cccc}
% (~L, & \dot\theta_{set}=6, & \xi:false, & T:5), \\
% (~R, & \dot\theta_{set}=6, & \xi:false, & T:5) \\
% \end{array} \right)\\
% \end{align*}
% The wheels are set to turn at 6 radians per second, and the action will complete
% in 5 seconds.  We might also define a TURN behavior, commanding the wheels to rotate \(\pi\) radians
% in opposite directions:
% \begin{align*}
% \mathrm{TURN} =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\
% Pc \left( \begin{array}{cccc}
% (~L, & \theta_{set}=\theta_0+\pi, & \xi:\theta==\theta_0+\pi, & T:\infty), \\
% (~R, & \theta_{set}=\theta_0-\pi, & \xi:\theta==\theta_0-\pi, & T:\infty) \\
% \end{array} \right)\\
% \end{align*}
% 
% Here, \(\theta_0\) denotes the currently-sensed value of $\theta$ at the beginning of
% the TURN behavior.
% The action completes when both wheels actually reach their commanded angles of \(\theta_0\pm\pi\). To drive in a square, we compose DRIVE and TURN behaviors in series:
% 
% \begin{align*}
% \mathrm{SQUARE} = Sc (~\mathrm{DRIVE},~\mathrm{TURN},~\mathrm{DRIVE},~\mathrm{TURN},\\
% ~\mathrm{DRIVE},~\mathrm{TURN},~\mathrm{DRIVE},~\mathrm{TURN} )
% \end{align*}
\subsection{ Verification of Configurations and Behaviors} \label{sec:verify}

%\subsubsection{Verification of Configurations \TODO{Consider removing these subsection headings to save space}}\label{sec:verify_conf}
{\bf Verification of Configurations: }
In Section~\ref{sec:conf_composition}, we introduced the definition of configuration composition. During the design process, a user might attempt to compose configurations in a way that is unstable or physically impossible. By incorporating existing algorithms into the design process, we provide tools to automatically verify designs during construction, saving time that would otherwise be spent simulating or testing invalid designs.

Given a configuration $\mathcal{C}$ and state \(X_0\), we consider $\mathcal{C}$ to be valid in state \(X_0\) if it is gravitationally stable and free from self
collision between modules.  A robot is gravitationally
stable when it is balanced, and gravity does not create any net moment on it.
If this condition is not met, the robot could tip over and suffer damage.
%
%Mathematically, the robot is \textit{gravitationally stable} if the projection
%of its center of mass onto the group plane lies within the convex hull of its
%load-supporting contact points in the ground plane.
A \textit{self-collision}
occurs when two different parts of the configuration are commanded to occupy the
same location in space.  Self-collisions can also cause damage, and are almost
always unwanted.

% However, it might not be
% possible or safe to form the structure represented by the composed configuration
% with the actual modules. Consider the configuration shown in
% Figure~\ref{fig:smores_conf_collision}. It is easy to tell that such
% configuration is not ideal for any task, because the self-collision may damage
% those modules and result in instability of the system. Thus it is important to
% verify whether the configuration is valid or not for a given modular robot
% system.

% \begin{figure}
% \sidecaption
% \includegraphics[height=1in]{images/walkbot_collision.png}
% \caption{A configuration with self-collision \TODO{We might consider taking
% this figure out to save space. I think self-collision is easy enough to understand without a picture}}
% \label{fig:smores_conf_collision}
% \end{figure}

% \begin{definition}[Configuration Verification]
% Given a configuration $\mathcal{C}$ and state \(X_0\), we say $\mathcal{C}$ is valid in
% state \(X_0\) if it is gravitationally stable and free from self collision between
% modules.  
% % it satisfied the following set of properties:
% % \begin{itemize}
% % \item There is no collision between modules in the configuration.
% % \item The configuration is gravitationally stable.
% % \end{itemize}
% %Notice that in order to verify the validity of the configuration, one needs to know some properties of all modules for the given modular robot system, e.g. the geometry information, and the mass of each module.
% \end{definition}

To determine gravitational instability and
self-collision, we assume that the geometric, kinematic, and mass
information for each module are available. 
%
To check for self-collision, the positions and orientation of all modules are
obtained  through forward kinematics as in Definition~\ref{def:configuration}.
%Using the known module geometry, we  check
%whether any two modules occupy the same space. If so, there exists a self-
%collision in the configuration.
Our tool checks self-collision by
approximating modules as spheres, and checking the distance (radius) between all
pairs. Due to this approximation, false-positive collisions might be detected. When this happens, a user can easily spot the faulty detection in the final configuration and choose to ignore such warning.
More sophisticated techniques are available which efficiently produce
exact results \cite{pan2012fcl}, at the cost of higher complexity.
%
To offer instant feedback to the user when designing the configurations, we
 check gravitational stability by computing the location of the center of
mass of the configuration based on the known kinematics and mass properties of 
the modules.
% For the given configuration $\mathcal{C}$
% and state \(X_0\), the position of the center of mass is:
% \begin{equation*}
%  P_{\mathcal{C}}=\dfrac{\sum\limits_{\mathcal{M}\in \gamma(\mathcal{C})}{P(\mathcal{M})\cdot \mathcal{M}_m}}{\sum\limits_{\mathcal{M}\in \gamma(\mathcal{C})}{\mathcal{M}_m}}
% \end{equation*}
% where $\mathcal{M}_m$ is the mass of the module $\mathcal{M}$, and
% \(P(\mathcal{M})\) is a function returning the position coordinates of
% \(\mathcal{M}\) in the world frame.
%
We find the set of modules that have minimal position in the $z$ direction and consider them to
be in contact with the ground plane, treating their centroids as an approximate
set of ground contact points.
%A set of points in the $x$-$y$ plane can be extracted from $M_c$ as $\sigma=\{(\mathcal{M}.P.x, \mathcal{M}.P.y)\mid \mathcal{M} \in M_c\}$.
If the projection of the configuration center of mass onto the ground plane
lies within the convex hull of the ground contact points, gravity exerts no
moment and the configuration
is stable.

%\subsubsection{Verification of Behaviors}
\noindent{\bf Verification of Behaviors: }
In Section~\ref{sec:behavior-representation}, we introduced a novel motion description language for modular robots. Like
configurations, behaviors are automatically verified as the user composes them.
  In addition to being free from self-collision and gravitationally stable during
execution, a valid behavior also must not exceed the actuator or connector force
limits of the modules, and must be free from behavior conflict.
% 
% Since in this work, we do not consider command to disconnect modules, any disconnection detected during behavior execution is undesired.
% Since our motion description language allows behaviors to be composed in parallel,
% it is possible to compose two behaviors that simultaneously command one controller
% to hold more than one desired position; we refer to this as \textit{behavior
% conflict}.

  % Actions defined by the language can be combined to produce more complex behaviors. Similar to configuration composition, we want to make sure the composed behaviors are valid and safe to execute. For example, a behavior that results in two modules colliding during the execution should be considered unsafe.
% 
% \begin{definition}[Behavior Verification]
% A behavior is valid if: there are no collisions or behavior conflicts at any time
% during execution, and forces required to maintain all module connections and joint positions do not exceed their limit.
% Additionally, the maximum duration for which the configuration is not
% gravitationally stable during execution is less than a time bound $t_{max}$, and the configuration must be stable at the end of execution.
% \end{definition}

% \begin{definition}[Behavior Verification]
% A behavior is valid if it satisfies the following set of properties when controlling a configuration of a given modular robot system
% \begin{itemize}
% \item Modules do not collide at any time during the execution of the behavior.
% \item There are no behavior conflicts at any time during the execution.
% \item The configuration is gravitationally stable at the end of the execution.
% \item The maximum duration for which the configuration is not gravitationally stable during the execution is less than a time bound $t_{max}$.
% \end{itemize}
% \end{definition}
% State is the right term, so I deleted the TODO.
To verify a behavior with time duration  $T_B$, we discretize execution with a preset sampling time $t_B$. At each time step, we first detect behavior conflict by checking if different commands are given to the same joint of a module simultaneously. If there is no behavior conflict, we update the positions and orientations of all modules in the configuration based on the commands. We then check for self-collision and gravitational instability, using the methods described above.  
A behavior that results in self-collision during a single time step is considered
invalid. For gravitational stability, we specify a time bound
\(t_{max} > t_B\). A behavior is considered unstable if it
includes any period of instability longer than \(t_{max}\), or if the behavior is unstable at time \(T_B\) (at the end).

To check force limits, unlike other verifications for behaviors, we use an existing physics engine to detect unsafe conditions during simulation. By setting the maximum force that
can be supported by connectors and exerted by  joints, we are able to identify unsafe behaviors if we detect, during the behavior execution, any undesired module disconnection or a  mismatch between any
joints target position and actual  position.

%\TODO{Since this is not the implementation section, it might be better to describe
%the joint and actuator limit checks without mentioning specific physics engines.
% The specific engines can be included in the implementation section.}

%\TODO{I have copied this text here from the verification examples section. 
%I think putting it here makes sense, because it helps motivate why we are doing
%behavior verification.  It will also save space, since there is one less section
%heading.  If possible, try to cut down the text as well to save space.}
The need for verification becomes more important as design complexity increases. Consider a four-legged Walkbot example shown in Figure~\ref{fig:verification}-1. If the user sets two of the connections with different angle offset, the composed Walkbot configuration will have two legs pointing in the opposite direction of the other two legs, as shown in Figure~\ref{fig:verification}-1. Since the projection of the configuration's center of mass now falls out of the supporting base, the program will warn the user that the configuration is not gravitationally stable. As shown in Figure~\ref{fig:verification}-2, in simulation the configuration quickly fell to the ground due to the instability as warned by the program. 

Verification of behaviors  also aids the user in creating valid and safe robot behaviors. When designing the walking behavior for the Walkbot, if the user commands the front and rear leg at the same side of the robot to swing toward each other at the same time, the program will warn the user that there will be collision between modules in this behavior, as shown in Figure~\ref{fig:verification}-3. The image shown in Figure~\ref{fig:verification}-4 demonstrates the moment of collision during simulation.

There is a trade-off between the correctness and the efficiency of the verification. By reducing the sampling time $t_b$, more potential self-collisions or gravitational instability can be detected with the cost of longer computation time.
%However, we only need to conduct the verification when configurations and behaviors are created. The safety of the robot can still be guaranteed during run-time without any online verification.
However, since there is no real-time requirement (verification is done during
the design process, not at runtime), the computational cost of fine-resolution
verification is worthwhile in most cases.

Modules all have limits on the maximum force that is available to maintain connections with other modules and to drive each joint to desired positions. Thus, it is crucial to notify the user if there is no sufficient force from the module's hardware to execute a behavior while maintaining all module connections. 
As shown in Figure~\ref{fig:verification}-5, the program detected a disconnection when the user tried to lift a long cantilever arm. Figure~\ref{fig:verification}-6 demonstrates the disconnection in simulation.
 
%\begin{figure}
%\begin{center}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/designer_unstable.png}
%                \caption{}
%                \label{fig:designer_unstable}
%           \end{subfigure}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/gazebo_unstable2.png}
%                \caption{}
%                \label{fig:gazebo_unstable2}
%        \end{subfigure}
%\end{center}
%\caption{(a) The program warns the composed configuration is not gravitationally stable; (b) The robot fell to ground plane due to instability in simulation}
%\label{fig:unstable}
%\end{figure}
%
%\begin{figure}
%\begin{center}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/designer_gait_collision.png}
%                \caption{}
%                \label{fig:gait_collision}
%           \end{subfigure}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/gazebo_gait_collision.png}
%                \caption{}
%                \label{fig:gait_collision2}
%        \end{subfigure}
%\end{center}
%\caption{(a) The program indicates there is collision during the behavior execution; (b) Two feet of  the robot collided during simulation}
%\label{fig:gait_unstable}
%\end{figure}
%
%\begin{figure}
%\begin{center}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/library/unity/breakJoint.png}
%                \caption{}
%                \label{fig:break_joint1}
%           \end{subfigure}
%        \begin{subfigure}[b]{0.48\columnwidth}
%                \includegraphics[width=\textwidth]{images/library/unity/breakJoint2.png}
%                \caption{}
%                \label{fig:break_joint2}
%        \end{subfigure}
%\end{center}
%\caption{(a) The program indicates there is undesired disconnection; (b) The configuration disconnected during simulation}
%\label{fig:break_joint}
%\end{figure}

\begin{figure}
%1 
\begin{overpic}[width=0.5\textwidth]{images/designer_unstable.png}
  \put(4,6) {(1)}
\end{overpic}
%2 
\begin{overpic}[width=0.5\textwidth]{images/gazebo_unstable2.png}
  \put(4,6) {(2)}
\end{overpic}
%3
\begin{overpic}[width=0.5\textwidth]{images/designer_gait_collision.png}
  \put(4,6) {(3)}
\end{overpic}
%4
\begin{overpic}[width=0.5\textwidth]{images/gazebo_gait_collision.png}
  \put(4,6) {(4)}
\end{overpic}
%5
\begin{overpic}[width=0.5\textwidth]{images/library/unity/breakJoint.png}
  \put(4,6) {(5)}
\end{overpic}
%6
\begin{overpic}[width=0.5\textwidth]{images/library/unity/breakJoint2.png}
  \put(4,6) {(6)}
\end{overpic}
\caption{From top and left: (1) The design tool warns the composed configuration is not gravitationally stable; (2) The robot fell to ground plane due to instability, in simulation; (3)
The design tool indicates there is collision during the behavior execution; (4) Two feet of  the robot collided during simulation; (5) The design tool indicates there is undesired disconnection; (6) The configuration disconnected during simulation.}
\label{fig:verification}
\end{figure}

%\subsection{Complexity}
%\TODO{Discuss the complexity of the algorithm with respect to the number of modules and size of gait tables.}

\section{Implementation }
\label{sec:implementation}
Our implementation currently supports only the SMORES modular robot \cite{Davey2012},  but
could easily  incorporate any other modular robot for which kinematic, geometric,
and mass information is available. Each SMORES modules has four DoF
- three continuously rotating faces called {\em turntables} and one
central hinge with a 180\textdegree\ range of motion (Figure~\ref{fig:graphical-representations}-1). The
DoF marked 1, 2, and 4 have rotational axes that are parallel and coincident.
Each SMORES module can drive around as a two-wheel differential
drive robot.
SMORES modules may connect to one another via magnets on each of their four
faces, and are capable of  self-reconfiguration.
Formally, we denote the state of a SMORES module as \(X=\lbrace \theta_L, \theta_R,
\theta_F, \theta_B \rbrace\) and the set of attachment points as \(A=\lbrace L,R,T,B \rbrace\).

% \begin{figure}[tb]
%   \sidecaption
%   \includegraphics[height=1.2in]{images/smores_robot.png}
%   \{SMORES robot \TODO{Could this be combined with figure 1?  Use it
%   as the single module}}
%   \label{fig:SmoresRobot}
% \end{figure}

A design interface was implemented to aid users in building complex configurations and behaviors from a set of basic configurations and associated behaviors,
and then verifying their correct execution. We separated the design tool into two main parts: a configuration builder and a behavior builder.
%\subsection{Configuration Builder}
Given a set of basic configurations (which could be just single modules), the configuration builder allows users to combine basic configurations by choosing connection nodes on each configuration, as demonstrated in Figure~\ref{fig:smores_conf}. In addition, the configuration builder warns users when the composed configuration is not stable or contains self-collisions. It does so without the computation complexity of a physical simulator, e.g. Gazebo
\cite{koenig2004design}.

%\subsection{Behavior Builder}
Given a composed configuration, the behavior builder aids users in designing behaviors for the composed configuration by arranging behaviors in a parallel and series composition. Figure~\ref{fig:smores_conf} illustrates a new behavior composed by putting four basic behaviors in parallel. Similar to the configuration builder, the behavior builder warns users if there are self-collisions or behavior conflict in the configuration during the execution of composed behaviors without the need of a physics-based simulator. To check force limits for connections and actuators, we create a
model of the module in the PhysX \cite{PhysX} physics engine with Unity3D \cite{Unity}, and specify joint and connection
force limits. 

\begin{figure}
\begin{center}
    \includegraphics[height=1.3in]{images/library/unity/config_designer.png}
    \includegraphics[height=1.3in]{images/gait_window.png}
    \caption{GUIs for configuration builder (left) and behavior builder (right)}
    \label{fig:smores_conf}
\end{center}
\end{figure}

% \begin{figure}
% \begin{center}
%         \begin{subfigure}[b]{0.49\columnwidth}
%                 \includegraphics[width=\textwidth]{images/conf_window.png}
%                 \caption{GUI for configuration builder}
%                 \label{fig:gui_conf}
%         \end{subfigure}   
%         \begin{subfigure}[b]{0.49\columnwidth}
%                 \includegraphics[width=\textwidth]{images/gait_window.png}
%                 \caption{GUI for behavior builder}
%                 \label{fig:gui_gait}
%         \end{subfigure}
% \end{center}
% \caption{The program to design and verify configurations and behaviors}
% \label{fig:smores_conf}
% \end{figure}
%
\section{Examples and User Perspective}
\label{sec:examples}
\vspace{-0.4cm}
Our eventual intention is to develop a large library of configurations and associated
behaviors which are available to all users of our framework, analogous to the standard
libraries of major programming languages.  The compositional nature of our framework
will allow users to rely heavily on the library when approaching new tasks, allowing
them to create sophisticated robots very quickly.

As a first step toward a standard library, we present a small library of configurations
in Figure~\ref{fig:library}.
Configurations in the library are organized by \textit{order}, defined recursively
as follows: a single module is an order-zero configuration, and the order of all
other configurations is one greater than the largest order of the sub-configurations
from which it is composed. Each configuration has an associated set of behaviors,
which the user can compose to accomplish tasks.  New behaviors for higher-order configuration can be created by composing the behaviors of its component sub-configurations.

For the library to be most effective, the set of configurations and behaviors available
 at each level (and especially at the lowest levels) should provide a rich set of
 functionalities without presenting the user with an overwhelming number of options. 
 Considering the small library in Figure~\ref{fig:library},
 it is interesting to note that a diverse set of second- and third-order configurations can
be constructed from only one zero- and one first-order configuration. Developing metrics to
evaluate the quality of such a library is an interesting opportunity for future work. 
%
% \begin{table*}
%      \begin{center}
%         \begin{tabular}{c c}
%          \includegraphics[scale=0.8]{images/library/tier0.pdf} &
%          \includegraphics[scale=0.8]{images/library/tier1.pdf} \\
%          \textbf{Order-0 (single module)} & \textbf{Order-1}
%         \end{tabular}
%          \caption{Order-0 and Order-1 configurations}
%          \label{Order-1-configurations}
%      \end{center}
% \end{table*}
% \begin{table*}
%     \begin{center}
%         \begin{tabular}{c c}
%         \includegraphics[scale=0.8]{images/library/tier2.pdf} &
%         \includegraphics[scale=0.9]{images/library/tier3.pdf} \\
%         \textbf{Order-2} & \textbf{Order-3}
%         \end{tabular}
%         \caption{Order-2 and Order-3 configurations}
%         \label{Order-2-configurations}
%     \end{center}
% \end{table*}
\begin{figure}
  \begin{center}
    \includegraphics[width=0.92\textwidth]{images/library/bigGrid.pdf}
    \caption{Library of designs, listed by order. 
    \textbf{Order 0:} Module. \textbf{Order 1:} Chain3=3x Module.
    \textbf{Order 2:} Car = Chain3 + 4x Module, Grasper = 3x Chain3, PUMA= Chain3 + Module.
    \textbf{Order 3:} Walkbot = 2x Grasper, Backhoe = 2x Car + PUMA.
    \textbf{Order 4:} Centaur = Walkbot + Grasper + 2x Module.}
    \label{fig:library}
  \end{center}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.92\textwidth]{images/tikz/design_diagram_hori.pdf}
\caption{The design flow}
\label{fig:design}
\end{center}
\end{figure}

\begin{figure}
  \begin{center}
    %1 
    \begin{overpic}[height=1in]{images/tikz/walkbot.pdf}
      \put(4,6) {(1)}
    \end{overpic}
    \hspace{1cm}
    %2 
    \begin{overpic}[height=1in]{images/tikz/walkbot2.pdf}
      \put(4,6) {(2)}
    \end{overpic}
    \caption{Building the Centaur. (1) Two Graspers are composed to form a Walkbot.
    (2) The Walkbot is composed with one more Grasper and two individual modules
    to form the Centaur.}
    \label{fig:centaur}
  \end{center}
\vspace{-2cm}
\end{figure}

%\subsection{The User Perspective}
Figure~\ref{fig:design} demonstrates the design flow when a user is designing a configuration and its behaviors. We present the start-to-end user perspective in designing a complicated configuration called Centaur. Consider the
order-1 `Chain3'' configuration. A second-order ``Grasper'' configuration, capable of grasping
objects, can be formed by combining three first-order ``Chain3'' configurations.   Combining two Graspers allows
us to form the legs and body of the third-order ``Walkbot'' configuration, now using the
Grasper arms as legs for walking, as demonstrated in Figure~\ref{fig:centaur}-1. If
we attach
another Grasper to the top of the Walkbot (with two additional modules for structural
support), we get the fourth-order ``Centaur'', a mobile manipulator, as shown in Figure~\ref{fig:centaur}-2. Connecting
multiple lower-order configurations allows us to quickly develop complex high-order
configurations like the Centaur. Given access to a library already containing
the Grasper design, for example, creating the Centaur is involves just two composition
steps.  The user can then immediately
compose behaviors already associated with the lower-order configurations (like``Walk'' and
``Grasp'') to create behaviors for higher-order configurations (like picking
up and carrying an object).

\vspace{-0.4cm}
\section{Conclusions}
\vspace{-0.4cm}
In this paper, we presented a design framework that facilitates the rapid creation
of configurations and behaviors for modular robots.
Complex configurations  are hierarchically constructed from basic
subcomponents.
We presented a novel motion description language, which allows existing behaviors
to be combined in series and parallel  to create more complex  behaviors.
The framework verifies  configurations and behaviors, allowing
early detection of  design flaws, specifically behavior conflict, self-collision, loss of gravitational stability, and forces 
exceeding the limits of safety for actuators and connectors. In addition to verification, designs can be evaluated in a physical simulator before testing on
hardware.

\vspace{-0.4cm}
\section{Future}
\vspace{-0.4cm}
Future work will include expansion of the features of our framework.  We hope to expand
the capabilities of our motion description language without sacrificing ease-of-use,
and add more verification tools to assist in problem identification. Another area of future work is developing a standard library of configurations and
behaviors for the SMORES robot.  We will also investigate metrics to evaluate the quality of such a library.
Perhaps most importantly, we will test and evaluate the designs and behaviors with actual hardware modules.
Currently, each behavior is associated with exactly one configuration. In many cases, a given behavior could be executed by several different configurations (if it were correctly mapped onto a subset of their modules). In the future, we will apply an embedding detection algorithm (see \cite{mantzouratos2014embeddability}) to map behaviors into any configuration capable of executing them.

Finally, while our implementation currently supports only SMORES, other modular
robots
could be easily incorporated. In the future, we plan to incorporate support
for the CKbot robot \cite{davey2012modlock} into our software. 

%\input{referenc}
%\bibliographystyle{plainnat}
\bibliographystyle{spmpsci}
\vspace{-0.4cm}
\bibliography{references}
\end{document}

































 

